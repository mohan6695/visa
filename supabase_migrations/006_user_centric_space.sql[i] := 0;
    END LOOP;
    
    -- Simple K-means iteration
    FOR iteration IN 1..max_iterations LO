-- Migration: User-Centric Personal Spaces
-- This migration creates a comprehensive user-centric data model with personalOP
        converged := TRUE;
        
        -- Assign each post to nearest cluster
        FOR post_record IN SELECT id, embedding FROM posts WHERE embedding IS NOT NULL LO spaces
-- for interview experiences, private messages, and user interactions

-- =============================================
-- USER PERSONAL SPACES
-- =============================================

-- User personal spaces table (each user gets their own space)
CREATE TABLE IF NOT EXISTS user_spaces (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
   OP
            old_assignment := cluster_assignments[post_record.id];
            new_assignment := 1; -- Default assignment
            
            -- Find nearest cluster center user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE NOT NULL,
    display_name TEXT NOT NULL,
    bio TEXT,
    profile_image_url TEXT,

            DECLARE
                min_distance FLOAT := 1.0;
                current_distance FLOAT;
                cluster_idx INT;
            BEGIN
    location TEXT,
    website_url TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Analytics                FOR cluster_idx IN 1..num_clusters LOOP
                    current_distance := 1 - (post_record.embedding <=> cluster_centers[cluster_idx]);
                    IF current_distance counters
    total_interviews INTEGER DEFAULT 0,
    total_posts INTEGER DEFAULT 0,
    total_messages_sent INTEGER DEFAULT 0,
    total_messages_received INTEGER DEFAULT 0,
    total > min_distance THEN
                        min_distance := current_distance;
                        new_assignment := cluster_idx;
                    END IF;
                END LOOP;
            END;
            
            IF old_assignment !=_answers INTEGER DEFAULT 0,
    total_comments INTEGER DEFAULT 0
);

-- User's interview experiences (personal space)
CREATE TABLE IF NOT EXISTS new_assignment THEN
                converged := FALSE;
                cluster_assignments[post_record.id] := new_assignment;
            END IF;
        END LOOP;
        
        -- Update cluster centers
        interview_experiences (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    
    -- Interview details
    company_name TEXT NOT NULL,
    position_title TEXT NOT NULL,
    interview_date DATE NOT NULL,
    location_type TEXT CHECK (location_type IN FOR cluster_idx IN 1..num_clusters LOOP
            cluster_centers[cluster_idx] := (SELECT AVG(embedding) FROM posts WHERE cluster_assign ('onsite', 'virtual', 'phone')) DEFAULT 'onsite',
    
    -- Content
    title TEXT NOT NULL,
    content TEXT NOT NULL,
ments[id] = cluster_idx);
        END LOOP;
        
        IF converged THEN
            EXIT;
        END IF;
    END LOOP;
    
    -- Return    tags TEXT[],
    
    -- Metadata
    difficulty_rating INTEGER CHECK (difficulty_rating BETWEEN 1 AND 5),
    outcome TEXT CHECK (outcome IN ('selected', 'rejected', 'waiting')),
    is_public BOOLEAN DEFAULT true,
    is_verified BOOLEAN DEFAULT false,
    
    cluster results
    FOR cluster_idx IN 1..num_clusters LOOP
        RETURN QUERY SELECT 
            cluster_idx,
            COUNT(*)::INTEGER,
            ARRAY -- SEO and search
    embedding VECTOR(1536),
    search_vector tsvector GENERATED ALWAYS AS (
        to_tsvector('english', title_AGG(DISTINCT SUBSTRING(content FROM 1 FOR 50)) -- Simple keyword extraction
        FROM posts 
        WHERE cluster_assign || ' ' || content || ' ' || company_name || ' ' || position_title)
    ) STORED,
    
    -- Timestamps
    created_at TIMESTments[id] = cluster_idx;
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get cluster statistics
CREATE OR REPLACE FUNCTION get_cluster_statistics()
RETURNS TABLE (
    cluster_id INTEGER,
    cluster_name TEXT,
    post_count INTEGER,
    avg_similarity_score FLOAT,
    keywords TEXT[]
AMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    -- Constraints
    CONSTRAINT valid_difficulty CHECK (difficulty_rating BETWEEN 1 AND 5)
);

-- User's personal posts (not group-based)
CREATE TABLE IF NOT EXISTS user_posts (
    id UUID DEFAULT gen_random_uuid()) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        pc.cluster_id,
        pc.cluster_name,
        pc.post_count,
        pc.avg_similarity_score,
        pc.keywords PRIMARY KEY,
    author_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    
    -- Post content
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    post_type
    FROM post_clusters pc
    ORDER BY pc.post_count DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create RLS policies for security
ALTER TABLE posts ENABLE ROW LEVEL SECURITY TEXT CHECK (post_type IN ('note', 'question', 'achievement', 'milestone', 'general')) DEFAULT 'general',
    
    -- Privacy and visibility
    visibility TEXT CHECK (visibility IN ('public', 'private', 'followers_only')) DEFAULT 'public',
    
    -- Metadata
    tags TEXT[],
    view_count INTEGER DEFAULT ;
ALTER TABLE post_clusters ENABLE ROW LEVEL SECURITY;

-- Policy for posts - allow read access to published posts
CREATE POLICY "Allow read access to published posts" ON posts0,
    like_count INTEGER DEFAULT 0,
    
    -- Search optimization
    embedding VECTOR(1536),
    search_vector tsvector GENERATED ALWAYS AS (
       
    FOR SELECT USING (status = 'published');

-- Policy for post_clusters - allow read access
CREATE POLICY "Allow read access to post clusters" ON post_clusters
    FOR to_tsvector('english', title || ' ' || content)
    ) STORED,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMEST SELECT USING (true);

-- Insert initial cluster templates
INSERT INTO post_clusters (cluster_name, keywords) VALUES
    ('H1B Visa Issues', ARRAY['h1AMPTZ DEFAULT NOW()
);

-- User personal comments (replies to user posts or interview experiences)
CREATE TABLE IF NOT EXISTS user_comments (
    id UUID DEFAULT genb', 'visa', 'work authorization', 'employer']),
    ('F1 Student Visa', ARRAY['f1', 'student', 'opt', 'cpt', 'i20_random_uuid() PRIMARY KEY,
    author_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    
    -- Parent content reference
    parent']),
    ('Visa Stamping', ARRAY['stamping', 'interview', 'consulate', 'passport']),
    ('Visa Revocation', ARRAY['revocation', '221g', '221i', 'revoked']),
    ('Green Card', ARRAY['green card', 'immigration', 'permanent residence', 'i485']),
    ('H4 Visa', ARRAY['h4', 'spouse', 'dependent', 'ead']),
    ('Travel and Port of Entry', ARRAY['travel', 'poe', 'entry', 'border']),
    ('Social Media Checks', ARRAY['social media', 'facebook', 'instagram', 'twitter']),
    ('Criminal Background', ARRAY['criminal', 'arrest', 'background', 'court']),
    ('General Immigration', ARRAY['immigration', 'status', 'change', 'adjustment'])
ON CONFLICT DO NOTHING;

-- Enable auto-update of updated_at
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp_posts
    BEFORE UPDATE ON posts
    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_timestamp();

CREATE TRIGGER set_timestamp_post_clusters
    BEFORE UPDATE ON post_clusters
_type TEXT CHECK (parent_type IN ('user_post', 'interview_experience', 'user_comment')) NOT NULL,
    parent_id UUID NOT NULL,
    
    -- Comment    FOR EACH ROW
    EXECUTE FUNCTION trigger_set_timestamp();

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT SELECT ON content
    content TEXT NOT NULL,
    
    -- Threading support
    parent_comment_id UUID REFERENCES user_comments(id) ON DELETE CASCADE,
    
    -- Metadata
    is_liked BOOLEAN DEFAULT false,
    like_count INTEGER DEFAULT 0,
    
    -- Timestamps
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT